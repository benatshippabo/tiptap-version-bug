// src/bubble-menu.ts
import { Extension } from "@tiptap/core";

// src/bubble-menu-plugin.ts
import {
  isNodeSelection,
  isTextSelection,
  posToDOMRect
} from "@tiptap/core";
import { Plugin, PluginKey } from "@tiptap/pm/state";
import debounce from "lodash/debounce";
import tippy from "tippy.js";
var BubbleMenuView = class {
  constructor({
    editor,
    element,
    view,
    tippyOptions = {},
    updateDelay = 250,
    shouldShow
  }) {
    this.preventHide = false;
    this.shouldShow = ({
      view,
      state,
      from,
      to
    }) => {
      const { doc, selection } = state;
      const { empty } = selection;
      const isEmptyTextBlock = !doc.textBetween(from, to).length && isTextSelection(state.selection);
      const isChildOfMenu = this.element.contains(document.activeElement);
      const hasEditorFocus = view.hasFocus() || isChildOfMenu;
      if (!hasEditorFocus || empty || isEmptyTextBlock || !this.editor.isEditable) {
        return false;
      }
      return true;
    };
    this.mousedownHandler = () => {
      this.preventHide = true;
    };
    this.dragstartHandler = () => {
      this.hide();
    };
    this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    };
    this.blurHandler = ({ event }) => {
      var _a;
      if (this.preventHide) {
        this.preventHide = false;
        return;
      }
      if ((event == null ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) == null ? void 0 : _a.contains(event.relatedTarget))) {
        return;
      }
      this.hide();
    };
    this.tippyBlurHandler = (event) => {
      this.blurHandler({ event });
    };
    this.updateHandler = (view, oldState) => {
      var _a, _b, _c;
      const { state, composing } = view;
      const { doc, selection } = state;
      const isSame = oldState && oldState.doc.eq(doc) && oldState.selection.eq(selection);
      if (composing || isSame) {
        return;
      }
      this.createTooltip();
      const { ranges } = selection;
      const from = Math.min(...ranges.map((range) => range.$from.pos));
      const to = Math.max(...ranges.map((range) => range.$to.pos));
      const shouldShow = (_a = this.shouldShow) == null ? void 0 : _a.call(this, {
        editor: this.editor,
        view,
        state,
        oldState,
        from,
        to
      });
      if (!shouldShow) {
        this.hide();
        return;
      }
      (_c = this.tippy) == null ? void 0 : _c.setProps({
        getReferenceClientRect: ((_b = this.tippyOptions) == null ? void 0 : _b.getReferenceClientRect) || (() => {
          if (isNodeSelection(state.selection)) {
            const node = view.nodeDOM(from);
            if (node) {
              return node.getBoundingClientRect();
            }
          }
          return posToDOMRect(view, from, to);
        })
      });
      this.show();
    };
    this.editor = editor;
    this.element = element;
    this.view = view;
    this.updateDelay = updateDelay;
    if (shouldShow) {
      this.shouldShow = shouldShow;
    }
    this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.addEventListener("dragstart", this.dragstartHandler);
    this.editor.on("focus", this.focusHandler);
    this.editor.on("blur", this.blurHandler);
    this.tippyOptions = tippyOptions;
    this.element.remove();
    this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: editorElement } = this.editor.options;
    const editorIsAttached = !!editorElement.parentElement;
    if (this.tippy || !editorIsAttached) {
      return;
    }
    this.tippy = tippy(editorElement, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: true,
      trigger: "manual",
      placement: "top",
      hideOnClick: "toggle",
      ...this.tippyOptions
    });
    if (this.tippy.popper.firstChild) {
      this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler);
    }
  }
  update(view, oldState) {
    const { state } = view;
    const hasValidSelection = state.selection.$from.pos !== state.selection.$to.pos;
    if (this.updateDelay > 0 && hasValidSelection) {
      debounce(this.updateHandler, this.updateDelay)(view, oldState);
    } else {
      this.updateHandler(view, oldState);
    }
  }
  show() {
    var _a;
    (_a = this.tippy) == null ? void 0 : _a.show();
  }
  hide() {
    var _a;
    (_a = this.tippy) == null ? void 0 : _a.hide();
  }
  destroy() {
    var _a, _b;
    if ((_a = this.tippy) == null ? void 0 : _a.popper.firstChild) {
      this.tippy.popper.firstChild.removeEventListener(
        "blur",
        this.tippyBlurHandler
      );
    }
    (_b = this.tippy) == null ? void 0 : _b.destroy();
    this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.removeEventListener("dragstart", this.dragstartHandler);
    this.editor.off("focus", this.focusHandler);
    this.editor.off("blur", this.blurHandler);
  }
};
var BubbleMenuPlugin = (options) => {
  return new Plugin({
    key: typeof options.pluginKey === "string" ? new PluginKey(options.pluginKey) : options.pluginKey,
    view: (view) => new BubbleMenuView({ view, ...options })
  });
};

// src/bubble-menu.ts
var BubbleMenu = Extension.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    if (!this.options.element) {
      return [];
    }
    return [
      BubbleMenuPlugin({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        updateDelay: this.options.updateDelay,
        shouldShow: this.options.shouldShow
      })
    ];
  }
});

// src/index.ts
var src_default = BubbleMenu;
export {
  BubbleMenu,
  BubbleMenuPlugin,
  BubbleMenuView,
  src_default as default
};
